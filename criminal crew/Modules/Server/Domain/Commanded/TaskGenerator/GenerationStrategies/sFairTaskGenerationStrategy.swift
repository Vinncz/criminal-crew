/// Picks panel who has the lowest amount of ``GameTask`` object generated by them.
public struct FairTaskGenerationStrategy : TaskGenerationStrategy {
    
    public var id : String = "FairTaskGenerationStrategy"
    
    public var contributionScale_taskDistribution : Double = 1
    public var contributionScale_gameProgression  : Double = 1
    public var contributionScale_panelComposition : Double = 1
    
    public func pickPanelToOrderFrom ( amongDistributionOf distribution: [Range<Double> : ServerGamePanelId] ) -> ServerGamePanelId {
        if let (_, lowestId) = distribution.min(by: { $0.key.lowerBound < $1.key.lowerBound }) {
            return lowestId
        } else {
            return distribution.first?.value ?? ""
        }
    }
    
    public func assess ( panelComposition: [ServerGamePanelId] ) -> TaskGenerationAssessmentUponPanelComposition {
        let hardPanelIds : [ServerGamePanelId] = [
            ServerClockPanel.panelId,
            ServerWiresPanel.panelId,
        ]
        
        let countOfPanelsConsideredHard : Int = panelComposition.filter({ hardPanelIds.contains($0) }).count
        
        return TaskGenerationAssessmentUponPanelComposition (
            taskModifierComponent: GameTaskModifierComponent (
                criteriaLength      : 0, 
                instructionDuration : Double(countOfPanelsConsideredHard) * 0.1 // add 10% leniency for every hard panels
            )
        )
    }
    
    public func assess ( successCount: Double, winningLimit: Double, failCount: Double, losingLimit: Double ) -> TaskGenerationAssessmentUponGameProgression {
        let introductoryPhase : ClosedRange<Double> = 0...0.35
        let midGamePhase      : ClosedRange<Double> = 0.36...0.8
            let upperMidPhase : ClosedRange<Double> = 0.65...0.8
        let closingPhase      : ClosedRange<Double> = 0.81...1
        
        var instructionLeniency : Double = 0
        if ( introductoryPhase.contains(successCount / winningLimit) ) {
            instructionLeniency = 0.1
        } else if ( midGamePhase.contains(successCount / winningLimit) ) {
            instructionLeniency = 0
        } else if ( closingPhase.contains(successCount / winningLimit) ) {
            instructionLeniency = -0.1
        }
        
        var criteriaLeniency : Double = 0
        if ( introductoryPhase.contains(successCount / winningLimit) ) {
            criteriaLeniency = -0.1
        } else if ( midGamePhase.contains(successCount / winningLimit) ) {
            criteriaLeniency = 0
        } else if ( upperMidPhase.contains(successCount / winningLimit) ) {
            criteriaLeniency = 0.1
        } else if ( closingPhase.contains(successCount / winningLimit) ) {
            criteriaLeniency = 0.2
        }
        
        return TaskGenerationAssessmentUponGameProgression (
            taskModifierComponent: GameTaskModifierComponent (
                criteriaLength      : criteriaLeniency, 
                instructionDuration : instructionLeniency
            )
        )
    }
    
}
